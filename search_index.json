[
["index.html", "Programirajmo u R-u (“Introduction to programming language R” course book) Foreword", " Programirajmo u R-u Damir Pintar 2017-10-05 (“Introduction to programming language R” course book) ** NOTE: During the current academic year, the “Introduction to Programming Language R” is revised chapter by chapter. After the subject is New chapters will be dynamically added to this HTML document. If you need to have access to all the materials, contact the author of the tutorial at damir.pintar@fer.hr** Foreword This tutorial is based on interactive lessons used in the “Introduction to Programming Language R” at the Faculty of Electrical Engineering and Computing at the University of Zagreb. But the topics discussed here are not only useful to the students of the mentioned faculty - knowledge of the language R will be good both in academia and in the business world. Although R is known as a “programming language made up of statisticians, for statisticians” and is most often associated with the field of data science within which it is used for complex statistical analysis and data mining, it can be very useful for tasks related to the management of smaller or larger data at tasks that are not necessarily strictly oriented to advanced analytics. Namely, popular graphical tools with their interactive tabular presentation are very intuitive and excellent for simpler tasks, but as the need for more complex tasks appears, they quickly lose their efficiency and simplicity; on the other hand, the interactive program approach offered by R is initially somewhat more demanding but long-term highly cost-effective because complex tasks can be dealt with in an efficient, consistent and insightful way. For this reason, in the business world there is a clear shifting trend from classic GUI office tools to platforms with better support for more complex calculations and the creation of attractive visualizations. This is evidenced by a strong increase in the popularity of R language and other platforms with similar approach to data analysis. The aforementioned popularity of R language results in an increased need for learning resources, which are not currently very much present in Croatia. This coursebook will try to make learning R as easy and interesting as possible through its “learning through examples” approach. Emphasis will be placed primarily on mastering R as a programming language. For this reason, the initial chapters will focus on “programmatical aspects”, followed by a review of available tools presumed to be useful for the widest set of readers - tools for data gathering, extracting useful information, and visualizations. Since R is a domain-oriented language, R’s role in its support for statistical analysis will be reviewed followed byexamining selected machine learning methods and their applications. Although there will be enough information to put all the presented methods into context, the idea of this textbook is not to teach readers statistics nor deeply enter the field of machine learning - the intention of the author is to intrigue readers to continue exploring this interesting area, adequately armed with platform knowledge that will enable all new knowledge is immediately practically applied in further research. "],
["introduction.html", "1 Introduction 1.1 What is R? 1.2 Installing Software Support 1.3 Overview of the development interface * RStudio * 1.4 How to use this coursebook?", " 1 Introduction 1.1 What is R? 1.1.1 General facts about R Programming language R came from the programming language S , developed for the needs of * Bell Telephone * Laboratory owned by * AT &amp; T * corporation. It was designed as an internal statistical analysis tool . The basic philosophy of the S language (inherited by the programming language R) was domain orientation - ie facilitating work with data analysts without the need to adapt conventions to traditional programming languages. Language S gained significant popularity in business analysts and statisticians within the 80s and 90s, but is now only available through a commercial variant called S-PLUS . The programming language R was created at the University of Auckland (NZ), modeled on S, and is released under the GNU Open Code Code . The standard distribution of the R programming language consists of: “core” R, with basic functions and so called “core” base package that provides basic functionality a collection of additional packages (“base” - * base * and “recommended” - * recommended *) for data management, visualization and statistical analysis We must not ignore the excellent integration of R with a rich repository called CRAN (Coprehensive R Archive Network *) that enables fast and easy installation of any packet from that repository, after which it becomes part of the local R installation. Since the R community is extremely strong in the development of new packages, often after the introduction of new experimental methods and access to data analysis, CRAN can quickly offer packages that implement them. Also, strong and continuous enthusiasm of the R community for the enhancment of existing R elements alleviates or eliminates a large number of detected language deficiencies. R is therefore often able to compare it with a “do it yourself” project where, after getting acquainted with the supplied “factory” components (in this case basic functions and packages), the user begins to adapt his development environment by choosing a package that exactly matches his needs and preferences. Creativity and flexibility in using R is considered to be of great advantage, although it results in a certain informality and liberal approach to programming is occasionally not favored by users familiar with strict and formal programming frameworks with a clear set of guidelines and rules to be followed Despite the exceptionally high acceptance of the R language for data analysis and the variety of options offered to the user, it is necessary to be aware of its limitations: R intensely uses RAM which has been considered a serious restriction for a long time; By increasing the capacity of modern hardware systems, this limitation is much more acceptable today, and there are also numerous packages that rationalize the use of memory. Still, the fact remains that R quickly eats the RAM of our computer, though it is often the result of the neglect or ignorance of a developer who has not adopted the “R” mode of programming well enough. R is quite unconventional so the learning curve is initially steeper, especially for programmers accustomed to standard conventions of other programming languages. On the other hand, if viewed long-term, programming in R is quite simple since most of the complex tasks are abstracted into high-level functions that transparently perform low-level operative tasks. It is often said that R is more oriented towards the goal we want to achieve and less detail about the way we reach it. R is not a “fast” language ; although it is a language that is expected to work over large data sets, R is not optimized for performance speed or even for parallelism; although there is a great deal of effort to implement virtually all key routines in C which prevents significant slowdowns, and there are a number of packages that allow multiple execution of the R program, the fact remains that R is not designed to be executed as quickly as possible ; If speed is a priority, it is often necessary to look for alternative solutions - which is why it is often said that R is primarily a research language, not a production language. R is primarily intended for interactive work , i.e. performing a series of machine instructions that are dynamically enrolled and executed with the help of a program console. This is tailored to the standard process of data analysis where the analyst can download data, clean it, transform, develop models, test, etc. with constant feedback from a computer an overview of intercepts , adapt the analysis process to current findings etc. This does not mean that programming language can not be programmed in a classical “procedural” way by developing algorithms encapsulated in functions that automatically perform their tasks after call, but the fact is that the efficiency of R is exactly reflected in interactive work. This principle is also transmitted to the teaching of R; programming language R is much easier to learn with interactive approaches by performing specific tasks, experimenting with data sets, accessible methods, and so on, rather than using a “classic” approach by designing scripts that implement some low-level jobs. 1.1.2 R alternatives Programming Language R is a popular but not the only solution for interactive data analysis and statistical programming. Below we will give a brief overview of some of the more popular technologies and solutions used today for this purpose, with a brief comparison and a review of the advantages and disadvantages compared to language R. SAS and SPSS - SAS (* Statistical Analysis System , developed by SAS Institute ) and SPSS ( Software Package for Statistical Analysis , developed by IBM *) are two different software packages that we put under the same paragraph primarily because they are commercial tools, ie tools that require full payment for their full functionality. Similarly, SAS and SPSS are relatively easy to learn and their functionality is largely based on carefully designed user interfaces. These tools emphasize efficiency and are an excellent option for large companies looking for a consistent, robust solution for their analytics, not bothered by the commercial nature of such solutions. Weka and Orange - Weka (* Waikato Environment for Knowledge Analysis, developed by Waikato University in New Zealand) and * Orange * (deep data analysis software developed at the University of Ljubljana) are free software for exploratory data analysis and data mining that base their functionality on relatively simple graphing interfaces and visual programming approach. These solutions are very good for users who are not too demanding in terms of the flexibility and complexity of their analysis because they allow the implementation of defined steps in the analysis process in a very accessible and clear way. This does not mean that these tools can not do more complex analysis, but they are still more suited to analyzes through the predefined functionality of the provided graphical interface. Python (Numpy / Pandas / Scikit) - in the last couple of years, Python is the most serious competitor of language R, primarily because Python is a very popular programming language with a very similar process approach to data analysis compared to one used by language R. The discussion of which language to choose is very common in the field of data science, usually without a clear final conclusion. It’s easy to make sure that the differences are in fact miniscule - while R is strongly domain-oriented and emphasis is placed on ease and ease of use with a wide range of available overlapping packages to enable the user to choose the one that best suits him, Python emphasizes the rigid formal structure and principle “for one job one way of doing”. Therefore, it could be said that R is somewhat more suitable for “data research” while Python’s advantage is easier to develop and integrate analytical modules in a production environment, especially if the above environment is already implemented in Python. But with the strong development of both languages and the mutual overlappiong of functionality, this distinction becomes less relevant - it is no longer a problem to integrate R scripts into existing systems regardless of the platform they are running on, and the Python community is developing its versions of popular packages from R that faithfully map their functionality. Ultimately, it can be said that the initial choice between these two alternatives is not so important - the approach they use is so similar and the functionality sharing is so pronounced that learning a single language introduce all of the major concepts from the other so data scientists often decide to master both languages, to more easily adapt to a large number of environments in which they must conduct their analyses. 1.2 Installing Software Support Installing the R language support software is pretty simple, especially if the recommended development interface RStudio is used as a platform. This is not the only option - one of the popular alternatives is the multilingual platform Jupyter Notebook which offers its own R support. Readers are ecnouraged to explore all available options and choose the final selection of the interface that personally matches their needs best, but this coursebook will focus on RStudio mainly because of a clear, easy-to-view interface, easy installation and a very rich support for a variety of functionalities - from installing new packages, easy retrieval of documentation, creating visualizations and publishing reports. Notions that will be discussed below will mostly assume that you have chosen an interface RStudio . To successfully set up a development platform, two things need to be installed language distribution R development interface RStudio It is recommended to use the latest available versions. At the time of writing this document, they are R 3.3.2 and RStudio 1.0.136 . If these versions differ from those on your computer, there will probably be no problem if the version numbers are higher than the above; otherwise, their upgrade is recommended. The procedure for installing this software on the operating system * Microsoft Windows * will be described below. If you are working on some other operating system, such as some * Linux * distribution or * Mac OS *, the procedure is somewhat different, but still not too complex - it’s enough to follow the instructions on the websites mentioned below that are a platform-oriented use. To find the software mentioned in the search engine, type the following terms: download R * download RStudio * In both cases, you will get links to the executable files that you have to run to install the software on your computer. In the case of R, this can be a file * R-3.3.2-win.exe * (exact numbers may differ). In the interface * RStudio * you can see more options - choose a free “* desktop *&quot; version. Commercial versions have some additional functionalities that are mostly oriented to use in professional multi-user environments and are not essential to normal work. You can run the executable files and let the wizard install all the necessary components on your computer. It is recommended to accept all of the nominal options except the installation folder - instead of the subfolder * * Program Files * “it is better to install R directly in the root folder (eg” * C:\\R\\R-3.3.2 * “). This way, it will be easier to find the currently installed version and eventually update it later. For the same reason, it is recommended that * RStudio * be installed in the folder”* C:\\R\\RStudio *“. If you do not have the option or you do not want to choose these folders, you can define some other or retain the default options - this choice should not ultimately affect the further work. After installing the interface * RStudio * it is enough to simply run it with the help of the created shortcut on the workbook (or alternatively, with the help of the executable file * RStudio.exe * in the selected installation folder). After launch, the application should look similar to the following image: Figure 1.1: RStudio interface layout If there are any problems, make sure that you have completed all of the installation steps listed above. Below we will deal with the details of the interface shown. 1.3 Overview of the development interface * RStudio * Let’s look at the interface * RStudio *. We see it being divided into three windows - the left part is the “work area” and the program code is entered into it. On the right, there are auxiliary windows that show different things, depending on the card selected; In the upper right hand corner, we can see, among other things, what is currently in our working environment (which is empty at the beginning) and the history of the commands that we have executed. The bottom part serves to display documentation, files, installed packages, visualizationa, etc. 1.3.1 Interactive console Let’s go back to the left part of the interface, especially the so-called. “interactive console”. Namely, by its nature, R is an “interpreter language” in the sense that commands are immediately interpreted and executed. Though it is possible to create larger scripts that are then executed “all at once”, working with the R language often comes down to the command-by-command principle. This is precisely why we are talking about “interactive program data analysis” - the analyst is “programming” by entering commands and can at any time study the interminent results obtained and decide on further steps. Let’s see how the interactive console works. With the help of a keyboard, you can type a simple math expression - eg 3 + 2 and press the * ENTER * key. We will see that R will immediately deliver the result - we can use it as a calculator! For mathematical expressions that are not simply “typed” we need to use functions. Thus, for example, a square root can be calculated using the sqrt () function. Let’s try typing sqrt(10) in the console and press * ENTER *. R again shows the result immediately. At this time, the screen should look like the next picture. Figure 1.2: R kao kalkulator One of the problems of using this kind of R is the mixing of commands and results, and the history of a string of commands becomes more and more cluttered as we use the console to move everything “lower and lower”. Likewise, if for some reason the command that we execute results in a mistake we are trying to correct, the console becomes “dirty” as mistakes are mixed with error reports, so any slightly more complicated procedure we want to run becomes “torn” and hard to interpret. This is why analysts often use so-called R scripts&quot; that allow you to visually distinguish the commands we want to execute from the console itself, but with the ability to easily transfer them in the console, where we then look at the result. 1.3.2 Writing R scripts In the toolbar, select File -&gt; New File -&gt; R Script (or press the CTRL + SHIFT + N key combination). We see that the “working area” on the left is divided into two parts. The upper part represents the space for our “script” - actually the series of commands we want to execute - while the interactive console now occupies the lower part of the work surface. If we want, we can tweak the size of these (and other windows) by moving the boundaries, but for now it’s important to have a look at the scripts and consoles. Write two commands in the script script - the first one should be print(' hello!') And underneath it a simple mathematical expression 3 + 4. Return the cursor to the first line and press the CTRL + ENTER key combination. If we have correctly followed these steps, the command at the cursor site will automatically be copied to the interactive console and executed. The cursor will now be the next command that you can do with CTRL + ENTER. The screen should now look similar to the next image. Figure 1.3: R script This is actually the usual way of working in R-language - entering the script space into commands that we then execute by automatically copying them into the console. If something is wrong with the command, we can easily modify it and perform it again. If you want to execute a block of commands, select them by clicking and dragging and then press the CTRL + ENTER key. Scripts can be expanded with comments (starting with the # character that R interprets as ‘ignore this line’). We can save our scripts under the chosen name on the hard disk. But we can go one step further. Though the R scripts are quite adequate for comfortable work in the R language, there is an additional technology that gives us even more flexibility in working with the R - * R Markdown *. 1.3.3 * R Markdown * Writing R scripts is very similar to the classic concept of “programming” - we write program commands that are usually executed sequentially, and optionally we add comments for the purpose of the documentation. But since a final step of data analysis usually involves formulating reports that will adequately display the results obtained, the RStudio interface supports technology that provides an effective combination of programming and structured documentation on the principle of “interactive notebooks”. The analyst can write “pure” text, optionally with formulas, images, and changes in the size and nature of the text font, and then can see both the executable code together and its results together, in a format resembling a notebook (in fact, RStudio recently introduced the R Notebook which works very similar to usual “interactive notebook” technologies). This technology is easiest to demonstrate through the examples - in the toolbar, select File -&gt; New File -&gt; R Markdown ... and in the next window choose an arbitrary title (eg &quot;Testing&quot;), optionally add the author’s name, and choose one of the options for final form of report (HTML is recommended due to the lowest dependency on additional packages). Unlike the R script, which will initially appear empty, with RMD R will create a “filled” document. This is done in this way for the simple reason that the user gets an easily modifiable template with all the basic elements included as a reminder. We will delete most of this template for our needs - everything after the initial header, ie below the second sign of ---. Then we can write any text below. With the #, ##, ### etc tags we can set the title of a certain section (they are now not commentaries because this is not R code!), While *and **signs in front and back we select the italic or bold font which weall appear in the final report. This is so-called. pure “* markdown *“, ie plain text that can be converted into formatted text with the help of additional tools, if desired. When we want to incorporate the program code into our “report”, we have to create so-called &quot; code chunk“. This can be done by selecting Insert -&gt; R on the toolbar or using the CTRL + ALT + I keys. Notice that the chunk begins and ends with a specially selected string of characters - three “backticks”. Likewise, the beginning of the chunk has description of certain parameteres in the opening brackets, the most important of which is the programming language we will use. In this textbook, we will almost exclusively use the language R, although other languages may be used if they are installed on the platform running * RStudio *. The code chunk behaves the same as the standard R script - we can enter commands and execute them. The difference is just that - if you want - the results can be seen immediately in the * R Markdown * document itself. If this option is not what we want, we can turn it off (click on the gear in the toolbar and select Chunk output in console) but in general we prefer to have the results right below the code that created them, notebook-style. If we follow the instructions, the screen may look similar to the following image: Figure 1.4: R Markdown document We can now try to create a “report” from the current document. First, we must save it under a particular name (eg Testing.rmd), and then we can click on the Knit button to convert the document from pure text to an HTML file. R Markdown documents are much more powerful than it may seem judging by the elements that have been presented so far. Chunks can have plenty of different parameters which influence their behavior. The output format can be PDF, DOCX as well as other forms such as slides of various technologies, books intended for mobile devices, interactive web applications etc. The coursebook you are reading is actually nothing more than a series of RMD files converted into the appropriate form you are currently using. As we will explain in the next chapter, RMD files are also the main way for you to use this coursebook effectively and try out the examples and tasks that follow. The universality and flexibility of technology * R Markdown * is exceptionally great, and is very well accepted by the R community. 1.4 How to use this coursebook? The basic idea of this coursebook is “learning through application”. Therefore, the lessons below will not use too many examples, but rather the reader will be encouraged to try out each new concept by solving a series of easy or intermediate tasks. Each chapter that follows has an accompanying “workbook”. Simply put, it is an RMD file that contains all the examples from the lecture, accompanied by a concise text for easier reference to the concepts being dealt with. The basic idea is that the reader reads the coursebook and solves the workbook in parallel, looking at the task solution only after it is solved within the programming tool. Some tasks will require simply removing the # sign (meaning “comment”) from the start of the command and executing it. In spite of the trivial approach, in this way, however, the reader is encouraged to independently test the command rather than just look at its result. Other tasks will require a bit more engagement. Finally, after each lesson there is a series of “Exercise Tasks” that will not have the solution and which will represent a kind of evaluation milestone of all the concepts of the lesson. Readers are strongly suggested solving all of the examples and tasks before moving on to the next lesson, as the lessons that follow presume the well-accepted knowledge of all the topics that are discussed previously. Of course, the textbook can be read without the above-mentioned “interactive” approach. Task solutions reveal the correct method of accessing the problem, and most of the commands are accompanied by a print that the user would get on the screen by executing them. Nevertheless, the coursebook author’s attitude is that programming languages can not be taught by reading, and that the extra effort to try all, even the simplest, concepts is ultimately very rewarding. Let’s get to know the concept of workbooks more closely. First you need to find and open a workbook that matches the lesson you are reading. It is easy to recognize by the appropriate number of lessons - the notebook for this lesson is named 01_Introduction_RB.Rmd. It is recommended that all workbooks that you plan to use are copied somewhere to the local computer together with all the accompanying files. As stated previously, the workbook will typically contain all the program code in the lesson to which it refers, but only enough pieces of text sufficient for easier understanding. If you read this text directly from the workbook and not as part of the tutorial, you can see that the entire previous lesson is missing; this is because the introductory steps described in it relate to the concepts that need to be adopted before using the workbook. If you have not passed them, it is a good idea to go back and pass them, and then continue with the following examples and tasks. Workbooks differ in Examples and Exercises. Examples are usually only required to be executed. Exercises on the other hand are expecting some changes or entering a new program code. As said, the tutorial will set far more emphasis on tasks. An example might look like this: Example - a few simple commands R of programming language 3 + 2 # adding log (10) # natural logarithm! log10 (10) # this is a base-10 logarithm! By the way, we comment with the &quot;#&quot; sin (0.5 * pi) # pi is one of the built-in constants ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 You can execute the commands from the examples individually, or the entire chunk at once with the CTRL + SHIFT + ENTER key combination. No modification of the code is necessary (although it is often not bad to experiment with the given commands!). Tasks on the other hand always require a certain - even minimal - intervention. Exercise 1.1 - commands for checking and editing workbooks # Make the following commands by removing the comment character #getwd () # folder in which we are currently working #setwd (&quot;.&quot;) # Here we can specify a new working folder if desired getwd() # directory in which we are currently working setwd(&quot;.&quot;) # Here we can specify a new work directory if desired The exercise will often refer to the just introduced concept. Eg. it is convenient to note that, although language R supports an operator = for assigning a value to a variable, it is recommended to use the &lt;- operator for that purpose, which is somewhat more “R-like”. Also, note that R supports the so-called. * autoprint *, ie always prints the result of the last command on the screen. This means that if we create a new variable x in the snippet and want to print it on the screen, we do not have to put print(x)as the last command, but just x. Let’s try this in the exercise. Exercise 1.2 - Assignment operator # put `5` in the variable` x` # then print the variable `x` on the screen x &lt;- 5 x ## [1] 5 Now that we are well acquainted with the work platform, we can begin by learning the basic elements of the R programming language. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "]
]
