[
["index.html", "Let’s program in R (“Introduction to programming language R” course book) Foreword", " Let’s program in R Damir Pintar 2017-10-10 (“Introduction to programming language R” course book) ** NOTE: During the current academic year, the “Introduction to Programming Language R” is revised chapter by chapter. After the subject is New chapters will be dynamically added to this HTML document. If you need to have access to all the materials, contact the author of the tutorial at damir.pintar@fer.hr** Foreword This tutorial is based on interactive lessons used in the “Introduction to Programming Language R” at the Faculty of Electrical Engineering and Computing at the University of Zagreb. But the topics discussed here are not only useful to the students of the mentioned faculty - knowledge of the language R will be good both in academia and in the business world. Although R is known as a “programming language made up of statisticians, for statisticians” and is most often associated with the field of data science within which it is used for complex statistical analysis and data mining, it can be very useful for tasks related to the management of smaller or larger data at tasks that are not necessarily strictly oriented to advanced analytics. Namely, popular graphical tools with their interactive tabular presentation are very intuitive and excellent for simpler tasks, but as the need for more complex tasks appears, they quickly lose their efficiency and simplicity; on the other hand, the interactive program approach offered by R is initially somewhat more demanding but long-term highly cost-effective because complex tasks can be dealt with in an efficient, consistent and insightful way. For this reason, in the business world there is a clear shifting trend from classic GUI office tools to platforms with better support for more complex calculations and the creation of attractive visualizations. This is evidenced by a strong increase in the popularity of R language and other platforms with similar approach to data analysis. The aforementioned popularity of R language results in an increased need for learning resources, which are not currently very much present in Croatia. This coursebook will try to make learning R as easy and interesting as possible through its “learning through examples” approach. Emphasis will be placed primarily on mastering R as a programming language. For this reason, the initial chapters will focus on “programmatical aspects”, followed by a review of available tools presumed to be useful for the widest set of readers - tools for data gathering, extracting useful information, and visualizations. Since R is a domain-oriented language, R’s role in its support for statistical analysis will be reviewed followed byexamining selected machine learning methods and their applications. Although there will be enough information to put all the presented methods into context, the idea of this textbook is not to teach readers statistics nor deeply enter the field of machine learning - the intention of the author is to intrigue readers to continue exploring this interesting area, adequately armed with platform knowledge that will enable all new knowledge is immediately practically applied in further research. "],
["introduction.html", "1 Introduction 1.1 What is R? 1.2 Installing Software Support 1.3 Overview of the development interface * RStudio * 1.4 How to use this coursebook?", " 1 Introduction 1.1 What is R? 1.1.1 General facts about R Programming language R came from the programming language S , developed for the needs of * Bell Telephone * Laboratory owned by * AT &amp; T * corporation. It was designed as an internal statistical analysis tool . The basic philosophy of the S language (inherited by the programming language R) was domain orientation - ie facilitating work with data analysts without the need to adapt conventions to traditional programming languages. Language S gained significant popularity in business analysts and statisticians within the 80s and 90s, but is now only available through a commercial variant called S-PLUS . The programming language R was created at the University of Auckland (NZ), modeled on S, and is released under the GNU Open Code Code . The standard distribution of the R programming language consists of: “core” R, with basic functions and so called “core” base package that provides basic functionality a collection of additional packages (“base” - * base * and “recommended” - * recommended *) for data management, visualization and statistical analysis We must not ignore the excellent integration of R with a rich repository called CRAN (Coprehensive R Archive Network *) that enables fast and easy installation of any packet from that repository, after which it becomes part of the local R installation. Since the R community is extremely strong in the development of new packages, often after the introduction of new experimental methods and access to data analysis, CRAN can quickly offer packages that implement them. Also, strong and continuous enthusiasm of the R community for the enhancment of existing R elements alleviates or eliminates a large number of detected language deficiencies. R is therefore often able to compare it with a “do it yourself” project where, after getting acquainted with the supplied “factory” components (in this case basic functions and packages), the user begins to adapt his development environment by choosing a package that exactly matches his needs and preferences. Creativity and flexibility in using R is considered to be of great advantage, although it results in a certain informality and liberal approach to programming is occasionally not favored by users familiar with strict and formal programming frameworks with a clear set of guidelines and rules to be followed Despite the exceptionally high acceptance of the R language for data analysis and the variety of options offered to the user, it is necessary to be aware of its limitations: R intensely uses RAM which has been considered a serious restriction for a long time; By increasing the capacity of modern hardware systems, this limitation is much more acceptable today, and there are also numerous packages that rationalize the use of memory. Still, the fact remains that R quickly eats the RAM of our computer, though it is often the result of the neglect or ignorance of a developer who has not adopted the “R” mode of programming well enough. R is quite unconventional so the learning curve is initially steeper, especially for programmers accustomed to standard conventions of other programming languages. On the other hand, if viewed long-term, programming in R is quite simple since most of the complex tasks are abstracted into high-level functions that transparently perform low-level operative tasks. It is often said that R is more oriented towards the goal we want to achieve and less detail about the way we reach it. R is not a “fast” language ; although it is a language that is expected to work over large data sets, R is not optimized for performance speed or even for parallelism; although there is a great deal of effort to implement virtually all key routines in C which prevents significant slowdowns, and there are a number of packages that allow multiple execution of the R program, the fact remains that R is not designed to be executed as quickly as possible ; If speed is a priority, it is often necessary to look for alternative solutions - which is why it is often said that R is primarily a research language, not a production language. R is primarily intended for interactive work , i.e. performing a series of machine instructions that are dynamically enrolled and executed with the help of a program console. This is tailored to the standard process of data analysis where the analyst can download data, clean it, transform, develop models, test, etc. with constant feedback from a computer an overview of intercepts , adapt the analysis process to current findings etc. This does not mean that programming language can not be programmed in a classical “procedural” way by developing algorithms encapsulated in functions that automatically perform their tasks after call, but the fact is that the efficiency of R is exactly reflected in interactive work. This principle is also transmitted to the teaching of R; programming language R is much easier to learn with interactive approaches by performing specific tasks, experimenting with data sets, accessible methods, and so on, rather than using a “classic” approach by designing scripts that implement some low-level jobs. 1.1.2 R alternatives Programming Language R is a popular but not the only solution for interactive data analysis and statistical programming. Below we will give a brief overview of some of the more popular technologies and solutions used today for this purpose, with a brief comparison and a review of the advantages and disadvantages compared to language R. SAS and SPSS - SAS (* Statistical Analysis System , developed by SAS Institute ) and SPSS ( Software Package for Statistical Analysis , developed by IBM *) are two different software packages that we put under the same paragraph primarily because they are commercial tools, ie tools that require full payment for their full functionality. Similarly, SAS and SPSS are relatively easy to learn and their functionality is largely based on carefully designed user interfaces. These tools emphasize efficiency and are an excellent option for large companies looking for a consistent, robust solution for their analytics, not bothered by the commercial nature of such solutions. Weka and Orange - Weka (* Waikato Environment for Knowledge Analysis, developed by Waikato University in New Zealand) and * Orange * (deep data analysis software developed at the University of Ljubljana) are free software for exploratory data analysis and data mining that base their functionality on relatively simple graphing interfaces and visual programming approach. These solutions are very good for users who are not too demanding in terms of the flexibility and complexity of their analysis because they allow the implementation of defined steps in the analysis process in a very accessible and clear way. This does not mean that these tools can not do more complex analysis, but they are still more suited to analyzes through the predefined functionality of the provided graphical interface. Python (Numpy / Pandas / Scikit) - in the last couple of years, Python is the most serious competitor of language R, primarily because Python is a very popular programming language with a very similar process approach to data analysis compared to one used by language R. The discussion of which language to choose is very common in the field of data science, usually without a clear final conclusion. It’s easy to make sure that the differences are in fact miniscule - while R is strongly domain-oriented and emphasis is placed on ease and ease of use with a wide range of available overlapping packages to enable the user to choose the one that best suits him, Python emphasizes the rigid formal structure and principle “for one job one way of doing”. Therefore, it could be said that R is somewhat more suitable for “data research” while Python’s advantage is easier to develop and integrate analytical modules in a production environment, especially if the above environment is already implemented in Python. But with the strong development of both languages and the mutual overlappiong of functionality, this distinction becomes less relevant - it is no longer a problem to integrate R scripts into existing systems regardless of the platform they are running on, and the Python community is developing its versions of popular packages from R that faithfully map their functionality. Ultimately, it can be said that the initial choice between these two alternatives is not so important - the approach they use is so similar and the functionality sharing is so pronounced that learning a single language introduce all of the major concepts from the other so data scientists often decide to master both languages, to more easily adapt to a large number of environments in which they must conduct their analyses. 1.2 Installing Software Support Installing the R language support software is pretty simple, especially if the recommended development interface RStudio is used as a platform. This is not the only option - one of the popular alternatives is the multilingual platform Jupyter Notebook which offers its own R support. Readers are ecnouraged to explore all available options and choose the final selection of the interface that personally matches their needs best, but this coursebook will focus on RStudio mainly because of a clear, easy-to-view interface, easy installation and a very rich support for a variety of functionalities - from installing new packages, easy retrieval of documentation, creating visualizations and publishing reports. Notions that will be discussed below will mostly assume that you have chosen an interface RStudio . To successfully set up a development platform, two things need to be installed language distribution R development interface RStudio It is recommended to use the latest available versions. At the time of writing this document, they are R 3.3.2 and RStudio 1.0.136 . If these versions differ from those on your computer, there will probably be no problem if the version numbers are higher than the above; otherwise, their upgrade is recommended. The procedure for installing this software on the operating system * Microsoft Windows * will be described below. If you are working on some other operating system, such as some * Linux * distribution or * Mac OS *, the procedure is somewhat different, but still not too complex - it’s enough to follow the instructions on the websites mentioned below that are a platform-oriented use. To find the software mentioned in the search engine, type the following terms: download R * download RStudio * In both cases, you will get links to the executable files that you have to run to install the software on your computer. In the case of R, this can be a file * R-3.3.2-win.exe * (exact numbers may differ). In the interface * RStudio * you can see more options - choose a free “* desktop *&quot; version. Commercial versions have some additional functionalities that are mostly oriented to use in professional multi-user environments and are not essential to normal work. You can run the executable files and let the wizard install all the necessary components on your computer. It is recommended to accept all of the nominal options except the installation folder - instead of the subfolder * * Program Files * “it is better to install R directly in the root folder (eg” * C:\\R\\R-3.3.2 * “). This way, it will be easier to find the currently installed version and eventually update it later. For the same reason, it is recommended that * RStudio * be installed in the folder”* C:\\R\\RStudio *“. If you do not have the option or you do not want to choose these folders, you can define some other or retain the default options - this choice should not ultimately affect the further work. After installing the interface * RStudio * it is enough to simply run it with the help of the created shortcut on the workbook (or alternatively, with the help of the executable file * RStudio.exe * in the selected installation folder). After launch, the application should look similar to the following image: Figure 1.1: RStudio interface layout If there are any problems, make sure that you have completed all of the installation steps listed above. Below we will deal with the details of the interface shown. 1.3 Overview of the development interface * RStudio * Let’s look at the interface * RStudio *. We see it being divided into three windows - the left part is the “work area” and the program code is entered into it. On the right, there are auxiliary windows that show different things, depending on the card selected; In the upper right hand corner, we can see, among other things, what is currently in our working environment (which is empty at the beginning) and the history of the commands that we have executed. The bottom part serves to display documentation, files, installed packages, visualizationa, etc. 1.3.1 Interactive console Let’s go back to the left part of the interface, especially the so-called. “interactive console”. Namely, by its nature, R is an “interpreter language” in the sense that commands are immediately interpreted and executed. Though it is possible to create larger scripts that are then executed “all at once”, working with the R language often comes down to the command-by-command principle. This is precisely why we are talking about “interactive program data analysis” - the analyst is “programming” by entering commands and can at any time study the interminent results obtained and decide on further steps. Let’s see how the interactive console works. With the help of a keyboard, you can type a simple math expression - eg 3 + 2 and press the * ENTER * key. We will see that R will immediately deliver the result - we can use it as a calculator! For mathematical expressions that are not simply “typed” we need to use functions. Thus, for example, a square root can be calculated using the sqrt () function. Let’s try typing sqrt(10) in the console and press * ENTER *. R again shows the result immediately. At this time, the screen should look like the next picture. Figure 1.2: R kao kalkulator One of the problems of using this kind of R is the mixing of commands and results, and the history of a string of commands becomes more and more cluttered as we use the console to move everything “lower and lower”. Likewise, if for some reason the command that we execute results in a mistake we are trying to correct, the console becomes “dirty” as mistakes are mixed with error reports, so any slightly more complicated procedure we want to run becomes “torn” and hard to interpret. This is why analysts often use so-called R scripts&quot; that allow you to visually distinguish the commands we want to execute from the console itself, but with the ability to easily transfer them in the console, where we then look at the result. 1.3.2 Writing R scripts In the toolbar, select File -&gt; New File -&gt; R Script (or press the CTRL + SHIFT + N key combination). We see that the “working area” on the left is divided into two parts. The upper part represents the space for our “script” - actually the series of commands we want to execute - while the interactive console now occupies the lower part of the work surface. If we want, we can tweak the size of these (and other windows) by moving the boundaries, but for now it’s important to have a look at the scripts and consoles. Write two commands in the script script - the first one should be print(' hello!') And underneath it a simple mathematical expression 3 + 4. Return the cursor to the first line and press the CTRL + ENTER key combination. If we have correctly followed these steps, the command at the cursor site will automatically be copied to the interactive console and executed. The cursor will now be the next command that you can do with CTRL + ENTER. The screen should now look similar to the next image. Figure 1.3: R script This is actually the usual way of working in R-language - entering the script space into commands that we then execute by automatically copying them into the console. If something is wrong with the command, we can easily modify it and perform it again. If you want to execute a block of commands, select them by clicking and dragging and then press the CTRL + ENTER key. Scripts can be expanded with comments (starting with the # character that R interprets as ‘ignore this line’). We can save our scripts under the chosen name on the hard disk. But we can go one step further. Though the R scripts are quite adequate for comfortable work in the R language, there is an additional technology that gives us even more flexibility in working with the R - * R Markdown *. 1.3.3 * R Markdown * Writing R scripts is very similar to the classic concept of “programming” - we write program commands that are usually executed sequentially, and optionally we add comments for the purpose of the documentation. But since a final step of data analysis usually involves formulating reports that will adequately display the results obtained, the RStudio interface supports technology that provides an effective combination of programming and structured documentation on the principle of “interactive notebooks”. The analyst can write “pure” text, optionally with formulas, images, and changes in the size and nature of the text font, and then can see both the executable code together and its results together, in a format resembling a notebook (in fact, RStudio recently introduced the R Notebook which works very similar to usual “interactive notebook” technologies). This technology is easiest to demonstrate through the examples - in the toolbar, select File -&gt; New File -&gt; R Markdown ... and in the next window choose an arbitrary title (eg &quot;Testing&quot;), optionally add the author’s name, and choose one of the options for final form of report (HTML is recommended due to the lowest dependency on additional packages). Unlike the R script, which will initially appear empty, with RMD R will create a “filled” document. This is done in this way for the simple reason that the user gets an easily modifiable template with all the basic elements included as a reminder. We will delete most of this template for our needs - everything after the initial header, ie below the second sign of ---. Then we can write any text below. With the #, ##, ### etc tags we can set the title of a certain section (they are now not commentaries because this is not R code!), While *and **signs in front and back we select the italic or bold font which weall appear in the final report. This is so-called. pure “* markdown *“, ie plain text that can be converted into formatted text with the help of additional tools, if desired. When we want to incorporate the program code into our “report”, we have to create so-called &quot; code chunk“. This can be done by selecting Insert -&gt; R on the toolbar or using the CTRL + ALT + I keys. Notice that the chunk begins and ends with a specially selected string of characters - three “backticks”. Likewise, the beginning of the chunk has description of certain parameteres in the opening brackets, the most important of which is the programming language we will use. In this textbook, we will almost exclusively use the language R, although other languages may be used if they are installed on the platform running * RStudio *. The code chunk behaves the same as the standard R script - we can enter commands and execute them. The difference is just that - if you want - the results can be seen immediately in the * R Markdown * document itself. If this option is not what we want, we can turn it off (click on the gear in the toolbar and select Chunk output in console) but in general we prefer to have the results right below the code that created them, notebook-style. If we follow the instructions, the screen may look similar to the following image: Figure 1.4: R Markdown document We can now try to create a “report” from the current document. First, we must save it under a particular name (eg Testing.rmd), and then we can click on the Knit button to convert the document from pure text to an HTML file. R Markdown documents are much more powerful than it may seem judging by the elements that have been presented so far. Chunks can have plenty of different parameters which influence their behavior. The output format can be PDF, DOCX as well as other forms such as slides of various technologies, books intended for mobile devices, interactive web applications etc. The coursebook you are reading is actually nothing more than a series of RMD files converted into the appropriate form you are currently using. As we will explain in the next chapter, RMD files are also the main way for you to use this coursebook effectively and try out the examples and tasks that follow. The universality and flexibility of technology * R Markdown * is exceptionally great, and is very well accepted by the R community. 1.4 How to use this coursebook? The basic idea of this coursebook is “learning through application”. Therefore, the lessons below will not use too many examples, but rather the reader will be encouraged to try out each new concept by solving a series of easy or intermediate tasks. Each chapter that follows has an accompanying “workbook”. Simply put, it is an RMD file that contains all the examples from the lecture, accompanied by a concise text for easier reference to the concepts being dealt with. The basic idea is that the reader reads the coursebook and solves the workbook in parallel, looking at the task solution only after it is solved within the programming tool. Some tasks will require simply removing the # sign (meaning “comment”) from the start of the command and executing it. In spite of the trivial approach, in this way, however, the reader is encouraged to independently test the command rather than just look at its result. Other tasks will require a bit more engagement. Finally, after each lesson there is a series of “Exercise Tasks” that will not have the solution and which will represent a kind of evaluation milestone of all the concepts of the lesson. Readers are strongly suggested solving all of the examples and tasks before moving on to the next lesson, as the lessons that follow presume the well-accepted knowledge of all the topics that are discussed previously. Of course, the textbook can be read without the above-mentioned “interactive” approach. Task solutions reveal the correct method of accessing the problem, and most of the commands are accompanied by a print that the user would get on the screen by executing them. Nevertheless, the coursebook author’s attitude is that programming languages can not be taught by reading, and that the extra effort to try all, even the simplest, concepts is ultimately very rewarding. Let’s get to know the concept of workbooks more closely. First you need to find and open a workbook that matches the lesson you are reading. It is easy to recognize by the appropriate number of lessons - the notebook for this lesson is named 01_Introduction_RB.Rmd. It is recommended that all workbooks that you plan to use are copied somewhere to the local computer together with all the accompanying files. As stated previously, the workbook will typically contain all the program code in the lesson to which it refers, but only enough pieces of text sufficient for easier understanding. If you read this text directly from the workbook and not as part of the tutorial, you can see that the entire previous lesson is missing; this is because the introductory steps described in it relate to the concepts that need to be adopted before using the workbook. If you have not passed them, it is a good idea to go back and pass them, and then continue with the following examples and tasks. Workbooks differ in Examples and Exercises. Examples are usually only required to be executed. Exercises on the other hand are expecting some changes or entering a new program code. As said, the tutorial will set far more emphasis on tasks. An example might look like this: Example - a few simple commands R of programming language 3 + 2 # adding log (10) # natural logarithm! log10 (10) # this is a base-10 logarithm! By the way, we comment with the &quot;#&quot; sin (0.5 * pi) # pi is one of the built-in constants ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 You can execute the commands from the examples individually, or the entire chunk at once with the CTRL + SHIFT + ENTER key combination. No modification of the code is necessary (although it is often not bad to experiment with the given commands!). Tasks on the other hand always require a certain - even minimal - intervention. Exercise 1.1 - commands for checking and editing workbooks # Make the following commands by removing the comment character #getwd () # folder in which we are currently working #setwd (&quot;.&quot;) # Here we can specify a new working folder if desired getwd() # directory in which we are currently working setwd(&quot;.&quot;) # Here we can specify a new work directory if desired The exercise will often refer to the just introduced concept. Eg. it is convenient to note that, although language R supports an operator = for assigning a value to a variable, it is recommended to use the &lt;- operator for that purpose, which is somewhat more “R-like”. Also, note that R supports the so-called. * autoprint *, ie always prints the result of the last command on the screen. This means that if we create a new variable x in the snippet and want to print it on the screen, we do not have to put print(x)as the last command, but just x. Let’s try this in the exercise. Exercise 1.2 - Assignment operator # put `5` in the variable` x` # then print the variable `x` on the screen x &lt;- 5 x ## [1] 5 Now that we are well acquainted with the work platform, we can begin by learning the basic elements of the R programming language. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["tipovi.html", "2 Basic data types and operators 2.1 Basic data types 2.2 Operators 2.3 Missing, unknown, and non-existent values Exercises", " 2 Basic data types and operators “Basic” or “primitive” types of data are the underlying building blocks of programming languages. They are basically embedded mechanisms that allow storing basic information - most commonly of logical, numeric, or character nature. Most programming languages use the same or very similar methods of storing such information, which means that they implement similar basic data types - the difference is often in details such as the actual type name, the nominal number of bytes, etc. In any case, the most common first step in learning a new programming language is to know the basic types of data that it supports. The next thing that may interest us is the language syntax, that is, the way we write commands that language interpreters can understand and execute. The R language in its syntax follows similar conventions seen in languages such as Python, Ruby, or Java, of course with certain specifics. Some basic syntax rules are: each command must, as a rule, go to its own line, but the indentation of commands is not as important as placing a point-to-end commands; defining blocks with bracketed brackets; we do not have to define the types of variables in advance since their type will be inferred by the assigned value; comments start with #; etc. Syntax will be best learned through examples - by learning the elements of the language syntax rules often become intuitively clear. It is best to start with simple functions and operators, as we will do in this lesson. We will end the lecture with a debate on the so-called. “missing” or “non-existent” values. Since R has its own way of defining this type of value, we will immediately clarify the way in which those in R are implemented so that in the following lessons the readers are prepared to easily manage such values (which often occur in work with actual data sets). 2.1 Basic data types R offers six basic data types: tip primjeri logical TRUE, FALSE ili T, F integer 2L, 5L, 123456789L double 4, 6, 3.14, 2e5 complex 5 + 2i, 7 + 1i character &quot;A&quot;, &quot;B&quot;, &quot;Pero&quot;, &quot;ABCDEFGHijklmnoPQRSTUVwyz&quot; raw as.raw(2), charToRaw(&quot;1&quot;) Some remarks: integer and real types are often treated together as a numeric type (although this is not entirely consistent!) complex type must have a declared imaginary constant even if it is 1 (2 + i is not a good record!) The type of “raw” bytes is relatively rarely used Checking whether a variable is of a certain type can work with the is.&lt;type_name&gt; function. We will try this in the next exercise. Before we begin with solving, we introduce one new feature: in exercises where we print more things on the screen, it is useful to visually separate the different print segments so that we can easily understand which part of the code is referenced. For this purpose, we will use the cat(&quot;-----------\\n&quot;) command that simply prints a dash of the line and goes to the new line. We could also use the print() function, but it always starts printing with the element index while the cat command is a “raw” print, which in this case is more appropriate. Exercise 2.1 - checking data types #try the following commands: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # perform the following checks: # is 5L numeric? # is 3.14 numeric? # is &quot;ABC&quot; character? # is 4 + 2i complex? # is 5 integer? is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) is.numeric(5L) is.numeric(3.14) is.character(&quot;ABC&quot;) is.complex(4 + 2i) is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Did you notice anything unusual in these checks? Try to explain the obtained results. Type some variables or constants we can retrieve with the typeof orclass function. The difference between them is the following: typeof - fetches&quot; primitive&quot; or “basic” type ( integer, double) class - ‘object type’, actually the value of class attribute Exercise 2.2 - data type retrieval # print the types of the following constants: TRUE, 2L, F, 3.14, &quot;ABC&quot; # print the classes of the same constants. Are there any differences? typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Data can be explicitly converted from one type to another using the function as.&lt;type_name&gt;: Exercise 2.3 - conversion of data types # perform the following conversions and print the result # 2.35 to integer # TRUE to ntomeric # 100L to character # 2.35 to character # 2e2 to character # 0 to logical # 2.75 to logical as.integer(2.35) as.numeric(TRUE) as.character(100L) as.character(2.35) as.character(2e2) as.logical(0) as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R will implement implicit conversion if possible: Exercise 2.4 - implicit conversion # Write the following phrases and print the results: # arithmetic operator between logical and numeric variables # arithmetic operator between integer and numeric variables # logical operator negation (!) applied to numeric variable # arithmetic operator between logical and numeric variables TRUE + 5 # arithmetic operator between integer and numeric variables 5L + 3.14 # logical operator negation (!) applied to numeric variable !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicit conversion will only be performed if it is meaningful - eg an arithmetic operator between the character and numeric variables will result in a mistake 2.2 Operators As in other programming languages, R permits the use of operators in terms. Some of the more frequently used operators are: arithmetic +, -, *, /, **, %% (modulo), %/% comparison &lt;, &lt;=, &gt;, &gt; =, ==, != logical ! (negation), &amp;&amp; (scalar AND), || (scalar OR), &amp; (vector AND), | (vector OR) assignment &lt;- or= Exercise 2.5 - operators # try the `5 / 2` and` 5%/% 2` expressions # check how much &quot;square of 17&quot; and &quot;the remainder of 101 divided by 12&quot; are # check what is the result of the following expressions: `17 &gt; 13`,`!TRUE`, `5 &amp;&amp; 0`,`0. || 2` # try the `5 / 2` and` 5%/% 2` expressions 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # check how much &quot;square of 17&quot; and &quot;the remainder of 101 divided by 12&quot; are 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # check what is the result of the following expressions: `17 &gt; 13`,`!TRUE`, `5 &amp;&amp; 0`,`0. || 2` 17&gt; 13 ! TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logical values and comparison operators will most commonly be used with so-called “Conditional Execution of Commands”, known from other programming languages as the “IF ELSE” commands. In R, its syntax looks like this: if (expression) {block} else {block} Let’s try this command on the following task: `r zadHead(“conditional execution”) ** # Write a command that performs the following: # &quot;if 100 is an even number print &#39;Success!&#39;&quot; if (100 %% 2 == 0) print(&quot;Success!&quot;) ## [1] &quot;Success!&quot; We have noted above that we have two types of logical operators for “and” and “or”. We will explain the difference later, for now it is enough to say that we are almost exclusively using &amp;&amp; i || (“C++” operators!) with the conditional execution of commands or program loops. Likewise, we have already mentioned that R offers two assignment operators, &lt;- and=. Let’s see if there are anz obvious differences between them. Exercise 2.6 - assignment operators # create variables x and y and assign the number 5, one with the operator &lt;-, # the other with the operator = # print variables on the screen # Do you notice any difference between these two operators? x &lt;- 5 y = 5 x y ## [1] 5 ## [1] 5 As we could testify, there is no noticeable difference between operator &lt;- and=. There are some minor differences, but they do not have any impact on the normal use of this operator in practice. In the literature, both versions can be seen for assigning values, but we will primarily and consistently use &lt;-, mostly because the code is visually more distinctive than the other programming languages. When assigning, we keep in mind that on the left there is so-called “left value” (lvalue). This is interpreted in the programmer’s sense as “something in which the calculated value can be stored”. x + 1 &lt;- 2 # error !!!] As a rule, in R as lvalue we can most commonly see a variable, though sometimes there may be a function call. This perhaps initially confusing feature will be clarified later. Naming the variables mostly follows the rules from other programming languages - letters, numbers, subfolders, and points are allowed. The first symbol must be a letter or a dot. .myVarijable &lt;- 5 #OK my.Variable &lt;- 5 #OK _myVariable &lt;- 5 # not OK 123Variable &lt;- 5 # not OK In practice for complex name variables we need to select one of the following conventions: myVariable &lt;- 1 # camelcase my_Variable &lt;- 2 # underscore seperation or my.variable &lt;- 3 # point separation It is important that we do not mix conventions in a program code, ie, after the selection, be consistent. If we insist on strange names using special characters, then we have to put them under the so called “left single apostrophes” (* backticks *): Exercise 2.7 - variable name with special characters # Enter an arbitrary name with special characters inside the left apostrophes # and print the value of the variable # `` &lt;- 2 `!% ^$*@ __ =` &lt;- 2 `!% ^$*@ __ =` ## [1] 2 Such a way of naming variables is not too useful in practice, but has its purpose - since the operators in R are actually functions (whose names are literally +, ** etc.) using left backticks we can directly reference them in their the original form, which can be very practical in the so-called functional programming (which we will talk about in one of the future lessons). Assigning values to new variable names we actually create new variables in the working environment (called the “global environment”“). All variables we have created so far can be seen with the ls() function. If we want to delete some variables, just give their names in the call function rm() (eg rm (x, y, z)). To delete * all * variables from the working environment, we use the call rm(list=ls ()), but we have to be careful (no”undo“!). Exercise 2.8 - printing and deleting global environment variables # print all of the global environment variables that have been created so far # delete some of the above-written variables - eg rm(x, y, z) # list all remaining variables # delete ALL variables from the global environment # (cautiously with this call in practice!) # Make sure the global environment is empty # print all of the global environment variables that have been created so far ls() # delete some of the above-written variables - eg rm(x, y, z) # list all remaining variables rm(x, y) ls() # delete ALL variables from the global environment # (cautiously with this call in practice!) # Make sure the global environment is empty rm(list=ls()) ls() Finally, whenever we need help with some function, we have the following options available: write only &lt;function_name&gt; (without parenthesis with parameters) and press - if the function is written in R (and not just proxy to a C implementation) the screen will get a printout of the original code function Write help (&lt;function_name&gt;) or ? &lt;name_functions&gt; to get a help function page with the list of parameters, examples, and so on. Write example (&lt;function_name&gt;) where we get a list of examples of using the function and the results obtained The following code snippet shows how to use the above methods (due to space savings, we do not show their result). #program code for `ls` function ls # help for `ls` function ?ls # or help(ls) # examples of using the `ls` function example(ls) 2.3 Missing, unknown, and non-existent values In R there are three ways of modeling “non-existent” values: NA - (* not available *) Missing or unknown value of a particular type NaN - (* not a number *) “impossible”number, eg 0 / 0 NULL - non-existent value, literally “nothing” Exercise 2.9 - working with NA, NaN and NULL # how much is &quot;5 + unknown number&quot; # how much is &quot;5 + non-existent number&quot; # check classes of the following: # NA # arithmetic operation between numeric and NA # NaN # NULL # how much is &quot;5 + unknown number&quot; 5 + NaN # how much is &quot;5 + non-existent number&quot; 5 + NA cat(&quot;-----------\\n&quot;) # check classes of the following: # NA # arithmetic operation between numeric and NA # NaN # NULL class(NA) # logical type is &quot;weakest&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NaN ## [1] NA ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Checking missing valuesis similar to checking data types - we use the is.na,is.nan and is.null functions. We have to keep in mind that NaN is a subclass of NA and that NULL is a completely separate class. This is especially important for SQL users - what is NULL in SQL isNA in R and that is what we normally use in practice, whereas NULL has very specific applications and is not so commonly used the program code. Exercise 2.10 - check NA, NaN and NULL # which of the following is NA? NA, NaN, NULL, &quot;&quot;, 0 # which of the following is NaN? NA, NaN, NULL # which of the following is NULL? NA, NaN, NULL # which of the following is NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # which of the following is NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # which of the following is NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE To end, we dedicate some room to a discussion of the NA value, since we will often encounter it in practice. Simply put, if the NA values appear, we can expect the following side effects: Results of arithmetic expressions result in NA values the results of some function call result with NA (unless we specify compensation actions, such as the parameter na.rm = T which actually means ‘ignore NA’) logical expression results may not necessarily result in a NA value depending on whether the term depends onNA or not (eg TRUE || NA has the result of TRUE, but FALSE || NA has result NA) With this last one, we must be especially careful as the NA in the conditional term results in a mistake: if (NA &lt;2) print (&quot;Success!&quot;) # error !! In this lesson we have come to know the basic elements of the language R. In working with R, we usually work with complex types of data that we will learn in the following - namely, vectors, matrices, data frames and lists. Exercises What is the result of the following commands? Consider a possible result before executing. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5 + 2i) as.numeric(&quot;ABC&quot;) How do the following expressions look like in R: “three times ten on the power of nine” “logarithm of 5” “integer division of 10 by 3” “the remainder of tnteger division of 10 by 3” “tangent of 75 degrees” | Using the if expression, check whether the result of dividing whole number with NULL is considered to beNA, NaN orNULL. Enter x in the variable5. Print all environment variables. Then put NULL in the x variable. Is this variable still there? Program in Ru &lt;/ span&gt; by Damir Pintar is licensed under Creative Commons Attribution-NonCommercial-NoDerivative 4.0 International License Based on a work at https://ratnip.github.io/FER_OPJR/ "],
["vektori.html", "3 Vectors, matrices and lists 3.1 Vector 3.2 Index vectors 3.3 Matrices and arrays 3.4 Lists Exercises", " 3 Vectors, matrices and lists 3.1 Vector The vector is one of the main “complex” types of data in the language R, in the sense that it contains more values of the same type. It is similar to the term “array” in the C language. But there is one important difference here, which is necessarily adopted since it is one of the most important characteristics of the language R - in R (almost) each variable type is actually a vector. Even the variables and constants we used in the previous lesson were actually single-element vectors. This has far-reaching consequences to be discussed in detail below, and to begin with, we will first get acquainted with the syntax of creating and managing vectors. 3.1.1 Create a vector The new vector(having more than one element) is created using the c (from * combine *) function. # numeric vector m &lt;- c(1, 2, 3, 4, 5) # logic vector v &lt;- c(T, F, T) # character vector names &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) So, simply said, the vector is arranged with a set of elements of the same type. If we create a new vector with elements of different types of data, R will automatically convert all elements into the “strongest” type, which will eventually become the type of vector itself (the term “stronger” type in this context means the type option to store all the information “stored in weaker” type, and in general the conversion goes in the direction of logic -&gt; numeric -&gt; character type). Exercise 3.1 - creating vectors # create a new vector `x` with four arbitrary elements of the following types: # logical, real, character and integer # print the vector content and its class screen # create a new vector `x` with four arbitrary elements of the following types: # logical, realistic, character and integer x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # print the vector content and its class on screen x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; The vector can be explicitly converted to another type with the help of already familiar functions as.&lt;type_name&gt;. If the conversion is impossible to implement, the element will be converted to NA with a suitable warning. Exercise 3.2 - explicit vector type conversion x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot;) # Consider a possible result and then try to make the following conversions # vector `x` in numeric type # vector `y` in character type # vector `z` in a whole type # Consider a possible result and then try to make the following conversions # vector `x` in numeric type # vector `y` in character type # vector `z` in a whole type as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Can you answer the question - why in the last example did the value TRUE not become 1L but NA instead? Try to print the z vector and notice the results of the implicit conversion you might have neglected (which converts the TRUE logical value to a string of &quot;TRUE&quot; that can no longer be ‘returned’ to the numeric value 1L). With the c function we can also connect multiple vectors to one: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # variable can be called &quot;c&quot; in spite of the function c() d &lt;- c(a, b, c) # d is now c(1, 2, 3, 4, 5, 6, 7, 8) In addition to the c function, R also offers additional convenient ways of creating new vectors: : - “range” operator, giving the range from upper to lower bound, both included seq - sequence function, similar to the range operator but with additional options rep - replicate function, repeats the provided elements provided number of times Exercise 3.3 - vector creation helper functions # print the results of the following commands # 1: 5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # print the results of the following commands 1: 5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vectors can also be created by means of functions corresponding to the names of the vector types (numeric,character, etc.) whereby as a parameter we specify the desired length of the vector. This is often done as a “preparation” of the vector for subsequent filling up of real values, ie, a kind of reservation of the place in memory. What is interesting is the fact that we can also create an “empty” vector of a certain type that is still a vector, with only the length of zero (for which, for example, with the function c we can add elements later). x &lt;- numeric(2) # vector is filled with &quot;null&quot; elements, in this case (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;empty&quot; vector! z &lt;- c(z, 1) # add to the vector the element 1 (actually &quot;merge empty vector and element 1&quot;) Finally, to check if some vector contains a certain element we can use the operator %in%: 4 %in% seq(1, 10, 2) # returns FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # returns TRUE Let’s see now how to access some vector elements 3.1.2 Operator [ The vector element is accessed through the index operator []`, with the help of which we can modify the vector elements: a &lt;- c(2, 4, 6) a[1] # prints a value of 2 a[2] &lt;- 5 # element on the 2nd place becomes 5 a[5] &lt;- 7 # at the 5th place is added 7, and the &quot;hole&quot; is filled with NA a ## [1] 2 ## [1] 2 5 6 NA 7 Notice a somewhat unusual fact - the first element of the vector in R has the index 1, not 0! This is an important difference compared to the indexing of elements in other programming languages. The reason for this specificity is simple - R is primarily considered as a language for data analysis, especially in tabular form, and in practice it is much easier to count rows or columns in order they appear in a data set than to do constantly “add 1”. The example above actually shows a very simplified case for retrieving vector elements and modifying them. One of the specifics of the language R is the so called vectorization, that is, the principle that R often works “more things at once” - not so much in terms of parallel execution, but in terms of declaring what we want to do. Specifically, in the case of vector indexing, we rarely retrieve or modify elements one by one, but rather we include a greater number of elements at once using the principle of vectorization and recycling. Understanding these terms is crucial for learning the R language, so we will explain them in detail below. 3.1.3 Principle of vectorization and recycling The notion of vectorization or more precisely vectorized operations and functions simply means that the operations work on multiple elements at once. If we ask R to make an operation or function over a vector of values, R will perform the function or operation over each element separately and return the vector as a result. Likewise, if we carry out the binary operation between two vectors, it will be performed over the “paired” or “aligned” elements of both vectors (suppose for now that the vectors are of the same length). Exercise 3.4 - vectorization principle x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # call the abs function to calculate the absolute value # over the vector `x` and print the result # add vectors `a` and` b` with operator `+` # and print the result # multiply vectors `a` and` b` with operator `*` # and print the result # call the abs function to calculate the absolute value # over the vector `x` and print the result abs(x) cat(&quot;-----------\\n&quot;) # add vectors `a` and` b` with operator `+` # and print the result a + b cat(&quot;-----------\\n&quot;) # multiply vectors `a` and` b` with operator `*` # and print the result a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Carefully consider the results of the previous task. If necessary, sketch the vector a andb on the paper with the vertically loaded elements and notice how to R does the “pairing” of the elements. Notice that we are not talking about “vector operations” here in a strict mathematical sense, but about aligning the elements of two vectors and performing simple operations over each of these pairs. This is especially evident in the last example where there is no “multiplication of vectors” in some of the mathematical interpretations, but rather simple multiplication of the parallel elements of the two vectors. What if the vectors are not of the same length? R in this case uses principle of recycling. The Recycle Principle states that when the vectors are uneven, the shorter vector is “recycled” as many times as needed to reach the longer length of the vector. The most common scenarios of using this principle are operations where on one side we have a vector with multiple elements and on the other a single element vector. What we should avoid is a recycling scenario where the length of a “big” vector is not a multiple of the “small” length - R will still recycle a shorter vector, only it will have to be “cut off”, which will result in an appropriate warning. Exercise 3.5 - recycle principle a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep (5, 3) # duplicate vector `a` and print the result # divide vector `a` with vector` b` and print the result # multiply vectors `a` and` c` and print the result a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep (5, 3) # duplicate vector `a` and print the result 2 * a # divide vector `a` with vector` b` and print result a / b # multiply vectors `a` and` c` and print the result a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Now we can finally demystify the difference between “scalar” and “vector” logic operators. Scala logical operators are intended for use with single-element vectors, they return unique values of TRUE or FALSE and are suitable for use in various conditional terms. Vector logical operators use standard R’s vectorization and recycling principles, ie, they are intended to work with logical vectors and as a result give a logical vector Exercise 3.6 - scalar and vector logical operators a &lt;- c(T, F, F) b &lt;- c(T, T, F) # apply scalar and vector version of logical operator &quot;or&quot; # over the `a` and` b` vectors and print the result # apply scalar and vector version of logical operator &quot;or&quot; # over the `a` and` b` vectors and print the result a || b a | b ## [1] TRUE ## [1] TRUE TRUE FALSE We see that the scalar version will “use” only the first pair of logic vector elements. This means we can use it in theory in conditional logic instructions, although there is no justified reason for it, and R will in this case warnus to address the fact that we are probably using the “wrong” operator. The next example with the comparison operators may initially seem trivial, but it is important to pay special attention to the results we get since they will have a very important implications later on. So let’s take a look at what happens in the vectorization of the parallel operators. Exercise 3.7 - vectorization of parallel operators x &lt;- 1:5 y &lt;- seq(-10, 10, 5) # print x and y # print the result of the x &gt; y command and explain the result # print the result of the x &lt; 3 command and explain the result # print x and y x y cat(&quot;-----------\\n&quot;) # print the result of the x &gt; y command and explain the result x&gt; y cat(&quot;-----------\\n&quot;) # print the result of the x &lt; 3 command and explain the result x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Thus, by vectorizing the comparison operators over the vectors (or combinations of vectors and scalars), as a result we get logical vectors. The interpretation of these results is crucial - it actually answers the question “on what indexes is the condition fulfilled by this expression”? In other words, the results actually represent a template that describes how to filter elements of a vector. This is the basic foundation of the so-called. logical Indexing, which is one of the indexing methods that we will learn below. 3.2 Index vectors We have already learned that a vector can be retrieved through a numerical index (and we did not forget the fact that the first element has an index 1). This concept can be expanded by taking multiple elements from the vector at once. which is often referred to as “slicing”. The basic principle of choosing multiple elements at once is simple - we only need to specify the indexes of the elements we want. R offers three basic ways of crawling: integer- or location- based indexing conditional or boolean-based indexing label-based indexing Which indexing we choose depends on whether we want to access the elements depending on their location, name, or condition, and each type of indexing essentially amounts to the use of a particular vector type as a parameter for the indexing operator. Such a vector is called an “index vector” because of its role. Let’s get to know each of the types of indexing in detail. 3.2.1 Location Indexing Location Indexing is the generalization of an already familiar indexing principle where we state the ordered numbers (indices) of elements we are interested in. If we want more elements, we simply put their indices “packed” into a numeric vector. Try solving the next task by using the appropriate numeric vectors as indexing parameters. Exercise 3.8 - location-based indexing x &lt;- 1:10 # print the first element of x # print the first three vector elements x # print the first, fifth, and seventh elements of the vector x # print the first element of x x[1] # print the first three vector elements x x[1:3] # print the first, fifth, and seventh elements of the vector x x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Thus, the location index vector is nothing other than the ordinary numeric vector we use together with the index operator to determine which elements of another vector we want to “keep”. Let’s look at some of the features of the location index vector: Exercise 3.9 - location indexing (2) x &lt;- 1:10 # answer the following questions with the help of an appropriate example # what does index 0 return? # what does a negative index return? # what happens if you use an index outside of vector boundaries x &lt;- 1:10 # answer the following questions with the help of an appropriate example # what does index 0 return? x[0] # what does a negative index return? x[-1] # what happens if you use an index outside of vector boundaries x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indexing is not only used to retrieve elements. By combining the indexing operator and the assignment operator we can change the vector elements (also by the principle of “multiple elements at once”: Exercise 3.10 - location-based indexing and assignment a &lt;- 1:10 # set all vector elements of `a` from the second to the eighth place to zero # print vector `a` b &lt;- 1:20 b [2 * 1:5] &lt;- 0 # Consider what the vector `b` looks like after the above command # print the vector `b` and explain the result a &lt;- 1:10 # set all vector elements of `a` from the second to the eighth place to zero # print vector `a` a [2:8] &lt;- 0 a b &lt;- 1:20 b [2 * 1:5] &lt;- NA # Consider what the vector `b` looks like after the above command # print the vector `b` and explain the result b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Conditional indexing If we carefully considered the results obtained with examples with vectorized comparison operators then we can very well grasp the way conditional indexing works. The principle is simple - for the index vector we set a logical vector of the same length as the vector whose elements we want to retrieve. The logic vector elements determine which elements are retained (the positions where the value is TRUE) and which we reject (positions where the value is FALSE). Exercise 3.11 - conditional indexing x &lt;- 1:10 # create a logical vector `y` of length 10 with an arbitrary combination of # TRUE and FALSE values # index the vector `x` with the` y` vector, print and explain the result # print all vector elements `x` which are less or equal to 5 # use the appropriate expression as a logical index vector x &lt;- 1:10 # create a logical vector `y` of length 10 with an arbitrary combination of # TRUE and FALSE values y &lt;-c(T, T, F, T, F, F, F, T, F, T) # index the vector `x` with the` y` vector, print and explain the result x[y] # print all vector elements `x` which are less or equal to 5 # use the appropriate expression as a logical index vector x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 The last command, while simple, is one of the key principles for filtering elements in the language R. The combination of the index operator and the conditional expression represents a concise but very powerful vector filtering mechanism. Let’s try this principle in a few more examples. Exercise 3.12 - conditional indexing y &lt;- seq (1, 100, 7) students &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # print all even, and then all odd vector elements of `y` # print all vector elements from `students` which represent 3-letter names # (note: we use the `nchar` function to count the characters in R) y &lt;- seq (1, 100, 7) students &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # print all even, and then all odd vector elements of `y` y[y %% 2 == 0] y[y %% 2 != 0] # print all vector elements from `students` which represent 3-letter names # (note: we use the `nchar` function to count the characters in R) students [nchar(students) == 3] ## [1] 8 22 36 50 64 78 92 ## [1] 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; If the concept of conditional indexing with the help of conditional expressions is still unclear, one of the things that can help is to sketch the intermediate results - simply print the result of the expression within the square bracket of the index operator and then consider how that result affects the final solution. 3.2.3 Label-based indexing label-based indexing works on the principle of explicitly naming the elements we want to “keep”. In order to be able to use this type of indexing we must meet the necessary prerequisite - vector elements must have predefined “names”. The vectors we used so far did not have named elements. Each element had its predefined position within the vector and its value but did not have any special additional identifiers. Programming language R allows you to attach names to vector elements in a very simple way - using a combination of the names function, the assignment operator, and the character vector with selected names. We need to make sure that the vector name is of the same length as the original vector! Exercise 3.13 - label-based indexing height &lt;- c(165, 173, 185, 174, 190) names (height) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # print the vector `height` # print the height of Pero and Josip height &lt;- c(165, 173, 185, 174, 190) names (height) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # print the vector `height` height # print the height of Pero and Josip height [c(&quot;Pero&quot;, &quot;Josip&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Josip ## 173 185 We see that label-based indexing needs a corresponding character vector as the index parameter. (NOTE: A more careful reader will notice an unusual fact in the program code - function call is used as a lvalue! Answer to the question why this works may require a little more knowledge of the internal functioning of the R language and for now it is enough to say that here it’s actually calling a function called names&lt;- which is “hidden” behind a much more intuitive and easy-to-understand syntax). If for some reason we want to delete the names of vector elements, simply forward NULL to names. names &lt;- NULL This will conclude the story of the index vectors. We learned different ways of creating a vector and getting and modifying its elements. Now is the time to try to add the additional “dimension” to the vectors - let’s get to know the matrices and the arrays. 3.3 Matrices and arrays The matrices and the arrays are simply - multidimensional vectors. Matrix is a vector of two dimensions, that is, a vector that organizes elements in “rows” and “columns”. Array is a vector with three or more dimensions. While matrices are used relatively often in practice, the arrays are somewhat more limited to specific scenarios. Because of this fact in this chapter we will mainly deal with matrices, although the concepts presented are very easily applicable to arrays. What is common to the matrices and arrays, which is a well-known fact to readers with programmatic experience, is that their multidimensionality is actually virtual. Both the matrix and the array are actually one-dimensional vectors with the attribute of dimensionality, and with this attribute the language R maps our multidimensional indexing to the “real” index of the element of the one dimensional vector. This fact does not limit us - we can still in most cases treat the matrix as if it is actually two-dimensional, and knowledge of one-dimensional nature can only give us additional flexibility in working with the matrices. There are several ways to create a new matrix: With the help of the matrix function to which we forward the one-dimensional vector and the desired number of rows and columns through the nrow and ncol parameters “manually” by setting dimensions of a one dimensional vector using the dim function and associating a two-element numeric vector with matrix dimensions “binding” rows or columns together with functions rbind (row-bind) andcbind (column-bind) We will demonstrate these ways in the following examples. Exercise 3.14 - matrix function x &lt;- 1:12 # create a matrix with 3 rows and 4 columns using the `matrix` function # print the result on the screen # repeat the procedure but add the parameter `byrow = T` to the calling function # print the result on the screen and compare it to the previous result # create a matrix with 3 lines and 4 columns using the `matrix` function # print the result on the screen matrix (x, nrow = 3, ncol = 4) # repeat the procedure but add the parameter `byrow = T` to the calling function # print the result on the screen and compare it to the previous result matrix (x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Note that unless explicitly requested otherwise, the R matrix is filled by columns. This is done because of the similarity of the matrix with the tabular representation of the data most often analyzed by looking at individual columns. But since we often feel that filling by the rows is more “natural”, we must not forget the very useful parameter of byrow. Exercise 3.15 - dim function m &lt;- 1:10 # print the result of call of the `dim` function to the vector` m` # use the `dim` function to vector` m` with the assigment of the vector c(2, 5) # print `m` and comment the result # print the call results of `nrow` and` ncol` on the matrix `m` m &lt;- 1:10 # print the result of call of the `dim` function to the vector` m` dim (m) # use the `dim` function to vector` m` with the assigment of the vector c(2, 5) dim (m) &lt;- c(2, 5) # print `m` and comment the result m # print the call results of `nrow` and` ncol` on the matrix `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 We see that the “ordinary” vector does not actually have a dimension, which is manifested by the NULL values we get as a result. By invoking the function dim we can add the attribute dim so it formally becomes a matrix (or array in general case). Exact dimensions are those that define how elements are organized in rows and columns, and by setting dimensions we need to be careful that they match the current number of elements. Once the matrix has dimensions added, we can retrieve them again by using the dim function, or just the number of rows or columns with the nrow and ncol functions. The resulting matrix is like the one in the previous example filled in by the columns. Since here we do not have the opportunity to use the byrow parameter, one of the ways to get a matrix filled by rows is to transpose the resulting result with the t function. m &lt;- t (m) # transpose the matrix and store it back in the variable `m` Finally, a matrix can be created by “gluing” rows and columns with the help of rbind andcbind. This is also a convenient way to add new rows and columns to an existing matrix. Exercise 3.16 - functions ‘rbind’ and ‘cbind’ a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0.0) # create a matrix `m` in which vectors `a` and `b` will be columns # add a new row to the top of the matrix `m` with vector elements` c` # print matrix `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0.0) # create a matrix `m` in which vectors` a` and `b` will be columns m &lt;- cbind (a, b) # add a new row to the top of the matrix `m` with vector elements` c` # print matrix `m` m &lt;- rbind (c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 3.3.1 Matrix splicing All the learned principles for “cutting” the vector using index vectors can be applied on matrices. The differences are as follows: we index each dimension individually first we index the lines, then the columns, and divide the index vectors by comma If we want “all rows” or “all columns” we simply omit this index vector( but we still use a comma) # assume that `m &#39;is a matrix of 3 x 5, with column names from `a` to `e` m[1, 2:5] # first line, all columns from second to fifth m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # second and third rows, columns `a` and` b` m[,] # all rows and all columns (same as just `m`) In practice, the matrix usually uses location-based and label-based indexing; conditional indexing is not too practical because of the two-dimensional nature of the matrix (although it is feasible, we just have to keep in mind that the logic index vector lengths correspond to the corresponding dimension). One of the things we need to keep in mind is the R-language tendency to “help” us by simplifying the result. Thus, the result of a row cutting operation that leaves only one row or column will automatically become a vector, ie lose the dimension attribute. This sometimes does not suit us, especially if we are working on scripts that expect a matrix further down the line, even though it has the dimension of rows or columns 1. In this case, we need to set an additional parameter drop = F for indexing. This often seems quite unattractive, which is why there are many R-language packages that “repair” this, that is to say, try to leave the results consistent. But the drop parameter set toFALSE should be taken into account, as it will appear in other places in a similar function. Exercise 3.17 - matrix splicing m &lt;- matrix (1:30, 6, 5, T) colnames (m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # print all elements of the matrix m from the second to the fourth line # and from the third to the fifth column # set all elements in column &quot;c&quot; to zero # and then print the first two lines of matrix `m` # print only column &quot;d&quot; # rewrite column &quot;d&quot;, but add the `drop = FALSE` parameter when indexing # Separate the parameter with a comma (as if it was a &quot;third&quot; indexing dimension) m &lt;- matrix (1:30, 6, 5, T) colnames (m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # print all elements of the matrix `m` from the second to the fourth line # and from the third to the fifth column m [2:4, 3:5] # set all elements in column &quot;c&quot; to zero # and then print the first two lines of matrix `m` m [, &quot;c&quot;] &lt;- 0 m [1:2] # print only column &quot;d&quot; m [, &quot;d&quot;] # rewrite column &quot;d&quot;, but add the `drop = FALSE` parameter when indexing # Separate the parameter with a comma (as if it was a &quot;third&quot; indexing dimension) m [, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## [1] 1 6 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 Here we will finish the story of the matrices. These structures are very useful in solving linear algebra tasks, so it is often convenient to look at the documentation of the R language to see which functions and operators are available to us for such a job. Similarly, some of the principles of matrix management will be useful in managing the so-called “data frames” - one of the most useful data structures in R. Finally, although we will not deal in detail with the arrays, we will show the example of the program code that creates a three-dimensional array and then uses standard cutting principles we encountered with the vectors and matrices. myArray &lt;- array(1:24, dim = c(2, 3, 4)) # array of dimension 2 x 3 x 4 myArray[, 1:2, 3, drop = FALSE] # print all rows, first and second columns # 3rd &quot;layer,&quot; with array type retention 3.4 Lists The list is an element in R used as a “universal container” of any data. Unlike the vector (ie, the concept of vector as we initially defined it), the list may contain different types of data or, more often, sets of different types of data. We create the list with the list function by which we add a string of names of elements and their content. These elements can be anything, even other lists. myList &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Try to create your own list in the following example. Exercise 3.18 - list creation # create a new list called `stuff` that will have the following elements # element called `numbers&#39; with integers from 1 to 3 # element called `letters&#39; with letters &#39;A&#39; and &#39;B&#39; # nameless element with logical vector `c(T, F)` # element called `titles&#39; with the concent of &#39;Mr&#39;, &#39;Mrs&#39; and &#39;Ms&#39; # print the `stuff` variable stuff &lt;- list(numbers = c(1,2,3), letters = c(&quot;A&quot;, &quot;B&quot;), c(T, F), titles = c(&quot;Mr&quot;, &quot;Mrs&quot;, &quot;Ms&quot;)) # print the `stuff` variable stuff ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $titles ## [1] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; Note that the list keeps the order of elements - the element without the name is shown in index 3. The str (“structure”) function allows us to inspect the properties and list contents without printing the entire list. This function is often used by analysts, both for viewing the list and for a quick insight into the already mentioned data frames that we will work with in the next chapter. Exercise 3.19 - list structure # print the structure of the `stuff` list # print the structure of the `stuff` list str(stuff) ## List of 4 ## $ numbers: num [1:3] 1 2 3 ## $ letters: chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ titles : chr [1:3] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; At the beginning of this lesson, we have said that the principle “all is a vector” is very important in R and that the vectors actually have arranged sets of elements of the same type. From this one could conclude that this fact is not valid for the lists - they obviously contain elements of different types. But the real answer is - the lists are actually vectors, and the definition is actually still consistent. That is, all the elements of the list are actually a small single-element lists, so all elements are formally of the same type. Exercise 3.20 - list element type # print the first element of the list `stuff` # check its type # print the first element of the list `stuff` stuff[1] # check its type typeof(stuff[1]) ## $numbers ## [1] 1 2 3 ## ## [1] &quot;list&quot; So, we’ve proved that the list elements are actually a small list, as seen from printing the item itself, as well as checking its type. It may seem that the elements above created lists should be vectors, since we have created the list by “stacking” different vectors, however in the process of list creation all these elements are wrapped in single-element lists. Often we do not want to work with a list element as a “small list”, but want to have it in its “original” form. For this we use the operator [[, ie the operator of “double angular brackets”. Exercise 3.21 - operator [[ # print the first element of the list `stuff` using the operator `[[` # check its type # print the first element of the list `stuff` using the operator `[[` stuff[[1]] # check its type typeof(stuff[[1]]) ## [1] 1 2 3 ## [1] &quot;double&quot; The aforementioned operator is most often used to retrieve the selected element of the list defined by the number or (if defined) by the element name. In this approach, we must use the syntax such as list[[name_element]] symbol, which is somewhat clumsy for typing. Because of this, R offers an alternative way of accessing the list elements by their name using the $ operator, ie list$name_element. Exercise 3.22 - operator ‘$’ # print the `letters` element of the `stuff` list # using `[[` the operator # print the `letters` element of the `stuff` list # using the `$` operator # print the `letters` element of the `stuff` list # using `[[` the operator stuff[[&quot;letters&quot;]] # print the `letters` element of the `stuff` list # using the `$` operator stuff$letters ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; The lists are an extremely popular type of object in R, as they represent a universal template for more complex data structures, including more complex objects in the narrower sense (as we will see later). The list is also the “foundation” for the most popular and most commonly used element of the R-language: the data frame - which we will learn in the next lesson. Finally, we learn how to add an element to the list. This is easiest to do using the aforementioned operator $ - such as list$newElement &lt;- newElementContents. The element is deleted by assigning the value NULL. Exercise 3.23 - adding list elements # in the `stuff` list add the `evenNumbers` element which contains # all even numbers from 1 to 100 # delete the third element from the list # print the `stuff` list # in the `stuff` list add the `evenNumbers` element which contains # all even numbers from 1 to 100 stuff$evenNumbers &lt;- seq(2, 100, 2) # delete the third element from the list stuff[[3]] &lt;- NULL # print the `stuff` list print(stuff) ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] &quot;A&quot; &quot;B&quot; ## ## $titles ## [1] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; ## ## $evenNumbers ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 ## [18] 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 ## [35] 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 In the next lesson, we will finally get to know the often-mentioned data frames as the most popular and most commonly used data structures of the language R. Exercises Create the following vectors: (11, 12, 13,…, 99) (0, 0, 0, 0, … , 0) (100 zeris) (0, 0.1, 0.2, …., 1.0) What is the sum of all numbers from 101 to 1001, if we skip all numbers divisible by 10? Use the sum function. Create a 3 x 3 matrix by performing the following commands (the sample function will be done in one of the following lessons): # we create a matrix of 3x3 randomly selected elements from 1 to 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Calculate the inverse matrix with the solve function. Make sure the multiplication of the original and inverse matrix result with the unit matrix (use the % *% operator to multiply the matrices). Initialize the stuff list used in the lesson. Do the following: print the class of the second element of the list print the element in the third place of the element of the list named letters check the length of the element called titles and add the title ‘Prof’ to the last position check if the number 4 is contained in the first element of the list add a new list of three vectors a,b and c which all contain elements (1,2,3) to the last place of the list, Program in Ru &lt;/ span&gt; by Damir Pintar is licensed under Creative Commons Attribution-NonCommercial-NoDerivative 4.0 International License Based on a work at https://ratnip.github.io/FER_OPJR/ "]
]
